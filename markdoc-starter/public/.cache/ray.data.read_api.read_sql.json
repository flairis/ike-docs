{
    "name": "ray.data.read_api.read_sql",
    "signature": "ray.data.read_api.read_sql(sql: str, connection_factory: Callable[[], Any], *, parallelism: int = -1, ray_remote_args: Optional[Dict[str, Any]] = None, concurrency: Optional[int] = None, override_num_blocks: Optional[int] = None) -> ray.data.dataset.Dataset",
    "summary": "Read from a database that provides a",
    "desc": "`Python DB API2-compliant <https://peps.python.org/pep-0249/>`_ connector.\n\n.. note::\n\n    By default, ``read_sql`` launches multiple read tasks, and each task executes a\n    ``LIMIT`` and ``OFFSET`` to fetch a subset of the rows. However, for many\n    databases, ``OFFSET`` is slow.\n\n    As a workaround, set ``override_num_blocks=1`` to directly fetch all rows in a\n    single task. Note that this approach requires all result rows to fit in the\n    memory of single task. If the rows don't fit, your program may raise an out of\n    memory error.",
    "args": [
        {
            "name": "sql",
            "type": null,
            "desc": "The SQL query to execute."
        },
        {
            "name": "connection_factory",
            "type": null,
            "desc": "A function that takes no arguments and returns a\nPython DB API2\n`Connection object <https://peps.python.org/pep-0249/#connection-objects>`_."
        },
        {
            "name": "parallelism",
            "type": null,
            "desc": "This argument is deprecated. Use ``override_num_blocks`` argument."
        },
        {
            "name": "ray_remote_args",
            "type": null,
            "desc": "kwargs passed to :meth:`~ray.remote` in the read tasks."
        },
        {
            "name": "concurrency",
            "type": null,
            "desc": "The maximum number of Ray tasks to run concurrently. Set this\nto control number of tasks to run concurrently. This doesn't change the\ntotal number of tasks run or the total number of output blocks. By default,\nconcurrency is dynamically decided based on the available resources."
        },
        {
            "name": "override_num_blocks",
            "type": null,
            "desc": "Override the number of output blocks from all read tasks.\nBy default, the number of output blocks is dynamically decided based on\ninput data size and available resources. You shouldn't manually set this\nvalue in most cases."
        }
    ],
    "returns": "A :class:`Dataset` containing the queried data.",
    "examples": [
        {
            "desc": null,
            "code": "For examples of reading from larger databases like MySQL and PostgreSQL, see\n:ref:`Reading from SQL Databases <reading_sql>`.\n\n.. testcode::\n\n    import sqlite3\n\n    import ray\n\n    # Create a simple database\n    connection = sqlite3.connect(\"example.db\")\n    connection.execute(\"CREATE TABLE movie(title, year, score)\")\n    connection.execute(\n        \"\"\"\n        INSERT INTO movie VALUES\n            ('Monty Python and the Holy Grail', 1975, 8.2),\n            (\"Monty Python Live at the Hollywood Bowl\", 1982, 7.9),\n            (\"Monty Python's Life of Brian\", 1979, 8.0),\n            (\"Rocky II\", 1979, 7.3)\n        \"\"\"\n    )\n    connection.commit()\n    connection.close()\n\n    def create_connection():\n        return sqlite3.connect(\"example.db\")\n\n    # Get all movies\n    ds = ray.data.read_sql(\"SELECT * FROM movie\", create_connection)\n    # Get movies after the year 1980\n    ds = ray.data.read_sql(\n        \"SELECT title, score FROM movie WHERE year >= 1980\", create_connection\n    )\n    # Get the number of movies per year\n    ds = ray.data.read_sql(\n        \"SELECT year, COUNT(*) FROM movie GROUP BY year\", create_connection\n    )\n\n.. testcode::\n    :hide:\n\n    import os\n    os.remove(\"example.db\")"
        }
    ]
}